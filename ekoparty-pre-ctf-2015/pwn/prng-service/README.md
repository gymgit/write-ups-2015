# EKOPARTY PRE-CTF 2015: PRNG Service

**Category:** Pwning
**Points:** 25
**Solves:** 141
**Description:**

> This is our PRNG service

> running at: nc challs.ctf.site 20003

>[pwn25](pwn25.zip)

## Write-up

by [polym](https://github.com/abpolym)

This writeup is based on following writeups:

* <https://ctf-team.vulnhub.com/eko-party-pre-ctf-2015-prng-service/>
* <https://0x90r00t.com/2015/09/20/ekoparty-pre-ctf-2015-pwn25-prng-service/>
* <https://github.com/ByteBandits/writeups/blob/master/ekoparty-pre-ctf-2015/pwn/prng-service/chaitan94/README.md>

We are given a zip that contains a [single C source code file](./pwn25.c).

We can see the following:

* A call of srandom with a hardcoded seed `1337`
* `ANSWER` from `answer.h` most likely contains the flag string, which is stored in a 128 byte sized buffer called `rnd` at pos `0`
* Starting from base index `64`, some random numbers are generated and stored into the rest of the buffer
* In a while loop, we can specify an index `signed int i` that we can read from the buffer from

The weaknesses of this program are:

* The seed is hardcoded, which means we can predict the pseudorandom numbers generated by srandom
* Since the index `i`, which we control (`scanf`), is `signed` that means we can provide negative numbers. `rnd[-64]` is `rnd[0]`

Using this knowledge, we can extract the flag beginning at `rnd[0]` through [this python script](./solve.py).

To reproduce this program:

* Compile the source code with `gcc -o pwn25 -I. pwn25.c`
* Run the program locally or in a VM (change the host accordingly) with `exec socat TCP-LISTEN:6666,fork,reuseaddr EXEC:./pwn25,echo=0,pty,stderr` - or just use `process()` of `pwntools`.
* Execute `solve.py`, retrieve the flag!

## Other write-ups and resources

* <https://ctf-team.vulnhub.com/eko-party-pre-ctf-2015-prng-service/>
* <https://0x90r00t.com/2015/09/20/ekoparty-pre-ctf-2015-pwn25-prng-service/>
* <https://github.com/ByteBandits/writeups/blob/master/ekoparty-pre-ctf-2015/pwn/prng-service/chaitan94/README.md>
